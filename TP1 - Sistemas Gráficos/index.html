<!doctype html>
<head>
    <script src="js/jquery.js"></script>
    <script src="js/gl-matrix-3.3.0.js"></script>    
    <script src="js/webgl-utils.js"></script>
    <script src="js/dat.gui.js"></script>
    <script src="discretizador.js"></script>
    <script src="modulo-geometria.js"></script>
    <script src="helicoptero.js"></script>
    <script src="handlers/controlHelicoptero.js"></script>
    <script src="handlers/mouseHandler.js"></script>
    <script src="handlers/keyboardHandler.js"></script>
    <script src="objeto3d.js"></script>
    <script src="textureManager.js"></script>
    <script src="plataformaHeli.js"></script>
    <script src="earth.js"></script>
    <script src="texturedSphere.js"></script>
    

    <style>
        html{
            height: 100%;
        }
        body{
            padding: 0;
            margin: 0;
            height: 100%;;
        }

        #myCanvas{
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
    </style>

</head>

<body>
           
    <canvas id="myCanvas" >
        Your browser does not support the HTML5 canvas element.
    </canvas>

    <button type="button" onclick="alert('Camaras:\n1\tCamara Global: Selecciona con numero 1 para activarla. Se puede mover haciendo click con mouse y moviendolo.\n2\tCamara seguimiento de atras. Selecciona con numero 2.\n3\tCamara de costado. Selecciona con numero 3.\n4\tCamara desde arriba. Selecciona con numero 4. \n5\t Se puede usar +|- para aumentar o disminuir el zoom')">Camaras</button>
     <button type="button" onclick="alert('Controles:\n1\tW: Mover para adelante.\n2\tS: Mover para atras.\n3\tA: Mover para izquiera.\n4\tD: Mover para derecha. \n5\tRePag: Subir el helicoptero. \n6\tAvPag: Bajar el helicoptero. \n7\tL: Bajar/Subir las alas')">Controles</button>
        
    
    <script>

        var vertexShaderFile="vertex-shader.glsl";
        var vertexShaderFileEarth="vertex-shader-earth.glsl";
        var vertexShaderFileSky="vertex-shader-sky.glsl";
        var vertexShaderFileSky="vertex-shader-water.glsl";
        var modo="smooth"; // wireframe, smooth, edges
        var shaderProgram;
        var shaderProgramEarth;
        var shaderProgramSky;
        var shaderProgramWater;
        var time=0;

        var gl;
        var mat4=glMatrix.mat4;
        var mat3=glMatrix.mat3;
        var vec3=glMatrix.vec3;   
        
        var textureManager;
        var sky;
        var agua;
            
        var $canvas=$("#myCanvas");
        var aspect=$canvas.width()/$canvas.height();

        var distanciaCamara=1.5;
        var alturaCamara=1.0;
        var velocidadAngular=0.0;
        var filas = 40;
        var columnas = 40;
        var segmentos=128;
        
        var lighting="true";

        var vertexShaderSource;
        var fragmentShaderSource;

        var vertexShaderEarthSource;
        var fragmentShaderEarthSource;

        var vertexShaderSkySource;
        var fragmentShaderSkySource;

        var vertexShaderWaterSource;
        var fragmentShaderWaterSource;

        var scale1=3;
        var low=0.1;
        var high=-0.03;

        var matrizProyeccion = mat4.create();            
        var matrizVista = mat4.create();            
        //var matrizModelado = mat4.create();

        var $window=$(window);    
        var $container = $('#container3D');
        var contenedorHelicoptero;

        //Camera variables
        var camera = 1;
        var mouseDown = false;
        var mouseX = 0.0;
    	var mouseY = 0.0;
    	var rotarCamaraX = 0.0;
    	var aumento = 0.0;
    	var rotarCamaraY = 0.0;
    	var eye_point = vec3.create();
	    vec3.set(eye_point, 0, 0, 0);
	    var up_point = vec3.create();
	    vec3.set(up_point, 0, 1, 0);
	    var at_point = vec3.create();
	    vec3.set(at_point, 0, 0, 0);
        
        var wKeyPressed = false
        var sKeyPressed = false
        var aKeyPressed = false
        var dKeyPressed = false
        var lKeyPressed = false
        

        function initGL(canvas) {

            try {
                gl = canvas.getContext("webgl");
                gl.canvas.width=$canvas.width();
                gl.canvas.height=$canvas.height();                
            } catch (e) {
                console.error(e);
            }
            if (!gl) {
                alert("Could not initialise WebGL, sorry :-(");
            }
        }

        function loadShaders(){

            $.when(loadVS(),loadVSEarth(), loadVSSky(), loadVSWater(), loadFS(), loadFSEarth(), loadFSSky(), loadFSWater()).done(function(res1,res2){
                //this code is executed when all ajax calls are done     
                webGLStart();
            });

            function loadVS() {
                return  $.ajax({
                    url: "shaders/"+vertexShaderFile,
                    success: function(result){
                        vertexShaderSource=result;
                    }
                });
            }

        	function loadVSEarth() {
                return  $.ajax({
                    url: "shaders/vertex-shader-earth.glsl",
                    success: function(result){
                        vertexShaderEarthSource=result;
                    }
                });
            }

            function loadVSSky() {
                return  $.ajax({
                    url: "shaders/vertex-shader-sky.glsl",
                    success: function(result){
                        vertexShaderSkySource=result;
                    }
                });
            }

            function loadVSWater() {
                return  $.ajax({
                    url: "shaders/vertex-shader-water.glsl",
                    success: function(result){
                        vertexShaderWaterSource=result;
                    }
                });
            }

            function loadFS() {
                return  $.ajax({
                    url: "shaders/fragment-shader.glsl",
                    success: function(result){
                        fragmentShaderSource=result;
                    }
                });
            }

            function loadFSEarth() {
                return  $.ajax({
                    url: "shaders/fragment-shader-earth.glsl",
                    success: function(result){
                        fragmentShaderEarthSource=result;
                    }
                });
            }

            function loadFSSky() {
                return  $.ajax({
                    url: "shaders/fragment-shader-sky.glsl",
                    success: function(result){
                        fragmentShaderSkySource=result;
                    }
                });
            }

            function loadFSWater() {
                return  $.ajax({
                    url: "shaders/fragment-shader-water.glsl",
                    success: function(result){
                        fragmentShaderWaterSource=result;
                    }
                });
            }
        }
        
        function getShader(gl,code,type) {

            var shader;

            if (type == "fragment") 
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            else // "vertex"
                shader = gl.createShader(gl.VERTEX_SHADER);
            
            gl.shaderSource(shader, code);
            gl.compileShader(shader);
    
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                return null;
            }    
            return shader;
        }
        
        function onResize(){
            gl.canvas.width=$canvas.width();
            gl.canvas.height=$canvas.height();
            aspect=$canvas.width()/$canvas.height();
           
        }

        function getShaderSource(url) {
            var req = new XMLHttpRequest();
            req.open("GET", url, false);
            req.send(null);
            return (req.status == 200) ? req.responseText : null;
        }; 

        function initShaders() {
    
            var vertexShader= getShader(gl, vertexShaderSource,"vertex");
            var fragmentShader= getShader(gl, fragmentShaderSource,"fragment");

            var vertexShaderEarth= getShader(gl, vertexShaderEarthSource,"vertex");
            var fragmentShaderEarth= getShader(gl, fragmentShaderEarthSource,"fragment");

            var vertexShaderSky= getShader(gl, vertexShaderSkySource,"vertex");
            var fragmentShaderSky= getShader(gl, fragmentShaderSkySource,"fragment");

            var vertexShaderWater= getShader(gl, vertexShaderWaterSource,"vertex");
            var fragmentShaderWater= getShader(gl, fragmentShaderWaterSource,"fragment");

            shaderProgram = gl.createProgram();
            shaderProgramEarth = gl.createProgram();
            shaderProgramSky = gl.createProgram();
            shaderProgramWater = gl.createProgram();

            gl.attachShader(shaderProgram, vertexShader);
            gl.attachShader(shaderProgram, fragmentShader);
            gl.linkProgram(shaderProgram);

            gl.attachShader(shaderProgramEarth, vertexShaderEarth);
            gl.attachShader(shaderProgramEarth, fragmentShaderEarth);
            gl.linkProgram(shaderProgramEarth);
    
            gl.attachShader(shaderProgramSky, vertexShaderSky);
            gl.attachShader(shaderProgramSky, fragmentShaderSky);
            gl.linkProgram(shaderProgramSky);

            gl.attachShader(shaderProgramWater, vertexShaderWater);
            gl.attachShader(shaderProgramWater, fragmentShaderWater);
            gl.linkProgram(shaderProgramWater);


            if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                alert("Could not initialise simple shaders");
            }

            if (!gl.getProgramParameter(shaderProgramEarth, gl.LINK_STATUS)) {
                alert("Could not initialise earth shaders");
            }

            if (!gl.getProgramParameter(shaderProgramSky, gl.LINK_STATUS)) {
                alert("Could not initialise sky shaders");
            }

            if (!gl.getProgramParameter(shaderProgramWater, gl.LINK_STATUS)) {
                alert("Could not initialise water shaders");
            }
    
            shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aPosition");
            gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
            shaderProgram.color = gl.getUniformLocation(shaderProgram, "RGB");
            shaderProgram.textureCoordAttribute = gl.getAttribLocation(shaderProgram, "aUv");
            gl.enableVertexAttribArray(shaderProgram.textureCoordAttribute);
            shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aNormal");
            gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);


            shaderProgramEarth.vertexPositionAttribute = gl.getAttribLocation(shaderProgramEarth, "aPosition");
            gl.enableVertexAttribArray(shaderProgramEarth.vertexPositionAttribute);
            shaderProgramEarth.textureCoordAttribute = gl.getAttribLocation(shaderProgramEarth, "aUv");
            gl.enableVertexAttribArray(shaderProgramEarth.textureCoordAttribute);
            shaderProgramEarth.vertexNormalAttribute = gl.getAttribLocation(shaderProgramEarth, "aNormal");
            gl.enableVertexAttribArray(shaderProgramEarth.vertexNormalAttribute);
            shaderProgramEarth.useReflectionUniform = gl.getUniformLocation(shaderProgramEarth, "uUseReflection");

            shaderProgramSky.vertexPositionAttribute = gl.getAttribLocation(shaderProgramSky, "aPosition");
            gl.enableVertexAttribArray(shaderProgramSky.vertexPositionAttribute);
            shaderProgramSky.textureCoordAttribute = gl.getAttribLocation(shaderProgramSky, "aUv");
            gl.enableVertexAttribArray(shaderProgramSky.textureCoordAttribute);
            shaderProgramSky.vertexNormalAttribute = gl.getAttribLocation(shaderProgramSky, "aNormal");
            gl.enableVertexAttribArray(shaderProgramSky.vertexNormalAttribute);
            shaderProgramSky.useReflectionUniform = gl.getUniformLocation(shaderProgramSky, "uUseReflection");

            shaderProgramWater.vertexPositionAttribute = gl.getAttribLocation(shaderProgramWater, "aPosition");
            gl.enableVertexAttribArray(shaderProgramSky.vertexPositionAttribute);
            shaderProgramWater.textureCoordAttribute = gl.getAttribLocation(shaderProgramWater, "aUv");
            gl.enableVertexAttribArray(shaderProgramWater.textureCoordAttribute);
            shaderProgramWater.vertexNormalAttribute = gl.getAttribLocation(shaderProgramWater, "aNormal");
            gl.enableVertexAttribArray(shaderProgramWater.vertexNormalAttribute);
            shaderProgramWater.useReflectionUniform = gl.getUniformLocation(shaderProgramWater, "uUseReflection");


            shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
            shaderProgram.mMatrixUniform = gl.getUniformLocation(shaderProgram, "uMMatrix");
            shaderProgram.vMatrixUniform = gl.getUniformLocation(shaderProgram, "uVMatrix");
            shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");
            shaderProgram.samplerUniform = gl.getUniformLocation(shaderProgram, "uSampler");
            shaderProgram.useLightingUniform = gl.getUniformLocation(shaderProgram, "uUseLighting");
            shaderProgram.ambientColorUniform = gl.getUniformLocation(shaderProgram, "uAmbientColor");
            shaderProgram.useColorUniform = gl.getUniformLocation(shaderProgram, "uUseColor");
            shaderProgram.frameUniform = gl.getUniformLocation(shaderProgram, "time");
            shaderProgram.lightingDirectionUniform = gl.getUniformLocation(shaderProgram, "uLightPosition");
            shaderProgram.directionalColorUniform = gl.getUniformLocation(shaderProgram, "uDirectionalColor");
            shaderProgram.lightingDirectionUniform2 = gl.getUniformLocation(shaderProgram, "uLightPosition2");
            shaderProgram.directionalColorUniform2 = gl.getUniformLocation(shaderProgram, "uDirectionalColor2");


            shaderProgramEarth.pMatrixUniform = gl.getUniformLocation(shaderProgramEarth, "uPMatrix");
            shaderProgramEarth.mMatrixUniform = gl.getUniformLocation(shaderProgramEarth, "uMMatrix");
            shaderProgramEarth.vMatrixUniform = gl.getUniformLocation(shaderProgramEarth, "uVMatrix");
            shaderProgramEarth.nMatrixUniform = gl.getUniformLocation(shaderProgramEarth, "uNMatrix");
            shaderProgramEarth.samplerUniform = gl.getUniformLocation(shaderProgramEarth, "uSampler");
            shaderProgramEarth.samplerUniform0 = gl.getUniformLocation(shaderProgramEarth, "uSampler0");
            shaderProgramEarth.samplerUniform1 = gl.getUniformLocation(shaderProgramEarth, "uSampler1");
            shaderProgramEarth.samplerUniform2 = gl.getUniformLocation(shaderProgramEarth, "uSampler2");
            shaderProgramEarth.samplerUniformReflection = gl.getUniformLocation(shaderProgramEarth, "uSamplerReflectionMap");
            shaderProgramEarth.useLightingUniform = gl.getUniformLocation(shaderProgramEarth, "uUseLighting");
            shaderProgramEarth.ambientColorUniform = gl.getUniformLocation(shaderProgramEarth, "uAmbientColor");
            shaderProgramEarth.frameUniform = gl.getUniformLocation(shaderProgramEarth, "time");
            shaderProgramEarth.lightingDirectionUniform = gl.getUniformLocation(shaderProgramEarth, "uLightPosition");
            shaderProgramEarth.directionalColorUniform = gl.getUniformLocation(shaderProgramEarth, "uDirectionalColor");
            shaderProgramEarth.lightingDirectionUniform2 = gl.getUniformLocation(shaderProgramEarth, "uLightPosition2");
            shaderProgramEarth.directionalColorUniform2 = gl.getUniformLocation(shaderProgramEarth, "uDirectionalColor2");

            shaderProgramSky.pMatrixUniform = gl.getUniformLocation(shaderProgramSky, "uPMatrix");
            shaderProgramSky.mMatrixUniform = gl.getUniformLocation(shaderProgramSky, "uMMatrix");
            shaderProgramSky.vMatrixUniform = gl.getUniformLocation(shaderProgramSky, "uVMatrix");
            shaderProgramSky.nMatrixUniform = gl.getUniformLocation(shaderProgramSky, "uNMatrix");
            shaderProgramSky.samplerUniform = gl.getUniformLocation(shaderProgramSky, "uSampler");
            shaderProgramSky.samplerUniformReflection = gl.getUniformLocation(shaderProgramSky, "uSamplerReflectionMap");
            shaderProgramSky.useLightingUniform = gl.getUniformLocation(shaderProgramSky, "uUseLighting");
            shaderProgramSky.ambientColorUniform = gl.getUniformLocation(shaderProgramSky, "uAmbientColor");
            shaderProgramSky.frameUniform = gl.getUniformLocation(shaderProgramSky, "time");
            shaderProgramSky.lightingDirectionUniform = gl.getUniformLocation(shaderProgramSky, "uLightPosition");
            shaderProgramSky.directionalColorUniform = gl.getUniformLocation(shaderProgramSky, "uDirectionalColor");
            shaderProgramSky.lightingDirectionUniform2 = gl.getUniformLocation(shaderProgramSky, "uLightPosition2");
            shaderProgramSky.directionalColorUniform2 = gl.getUniformLocation(shaderProgramSky, "uDirectionalColor2");

            shaderProgramWater.pMatrixUniform = gl.getUniformLocation(shaderProgramWater, "uPMatrix");
            shaderProgramWater.mMatrixUniform = gl.getUniformLocation(shaderProgramWater, "uMMatrix");
            shaderProgramWater.vMatrixUniform = gl.getUniformLocation(shaderProgramWater, "uVMatrix");
            shaderProgramWater.nMatrixUniform = gl.getUniformLocation(shaderProgramWater, "uNMatrix");
            shaderProgramWater.samplerUniform = gl.getUniformLocation(shaderProgramWater, "uSampler");
            //shaderProgramWater.samplerUniform1 = gl.getUniformLocation(shaderProgramWater, "uSampler1");
            shaderProgramWater.useLightingUniform = gl.getUniformLocation(shaderProgramWater, "uUseLighting");
            shaderProgramWater.ambientColorUniform = gl.getUniformLocation(shaderProgramWater, "uAmbientColor");
            shaderProgramWater.useColorUniform = gl.getUniformLocation(shaderProgramWater, "uUseColor");
            shaderProgramWater.frameUniform = gl.getUniformLocation(shaderProgramWater, "time");
            shaderProgramWater.lightingDirectionUniform = gl.getUniformLocation(shaderProgramWater, "uLightPosition");
            shaderProgramWater.directionalColorUniform = gl.getUniformLocation(shaderProgramWater, "uDirectionalColor");
            shaderProgramWater.lightingDirectionUniform2 = gl.getUniformLocation(shaderProgramWater, "uLightPosition2");
            shaderProgramWater.directionalColorUniform2 = gl.getUniformLocation(shaderProgramWater, "uDirectionalColor2");
        }

        function setMatrixUniforms() {
            
            gl.uniformMatrix4fv(shaderProgram.vMatrixUniform, false, matrizVista);
            gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, matrizProyeccion);
    
        }

        function setMatrixUniformsEarth() {
            
            gl.uniformMatrix4fv(shaderProgramEarth.vMatrixUniform, false, matrizVista);
           	gl.uniformMatrix4fv(shaderProgramEarth.pMatrixUniform, false, matrizProyeccion);
    
        }

        function setMatrixUniformsSky() {
            
            gl.uniformMatrix4fv(shaderProgramSky.vMatrixUniform, false, matrizVista);
            gl.uniformMatrix4fv(shaderProgramSky.pMatrixUniform, false, matrizProyeccion);
    
        }

        function setMatrixUniformsWater() {
            
            gl.uniformMatrix4fv(shaderProgramWater.vMatrixUniform, false, matrizVista);
            gl.uniformMatrix4fv(shaderProgramWater.pMatrixUniform, false, matrizProyeccion);
    
        }
              
        function drawScene() {
        
            // Se configura el viewport dentro del "canvas". 
            // En este caso se utiliza toda el área disponible
            gl.viewport(0, 0, $canvas.width(), $canvas.height());
            
            // Se habilita el color de borrado para la pantalla (Color Buffer) y otros buffers
            gl.clearColor(0.2,0.2,0.2,1);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    
            // Se configura la matriz de proyección
            mat4.identity(matrizProyeccion);
            mat4.perspective(matrizProyeccion, 30, aspect, 0.1, 100.0);
            mat4.scale(matrizProyeccion,matrizProyeccion,[1,-1,1]); // parche para hacer un flip de Y, parece haber un bug en glmatrix
               
            // Se inicializan las variables asociadas con la Iluminación           
            // Configuración de la luz
            // Sol
            var sunPosition = vec3.fromValues(500.0, 300.0, 500.0);

            gl.uniform1f(shaderProgram.frameUniform, time/10.0 );
            gl.uniform3f(shaderProgram.ambientColorUniform, 0.6, 0.6, 0.6 );
            gl.uniform3f(shaderProgram.directionalColorUniform, 1.2, 1.1, 0.7);
            gl.uniform1i(shaderProgram.useLightingUniform,(lighting=="true"));

            gl.uniform3fv(shaderProgram.lightingPrincipalDirectionUniform, sunPosition);
            gl.uniform3fv(shaderProgram.sunPositionUniform, sunPosition);
            gl.uniform1f(shaderProgram.lightPrincipalIntensity, 1.2);                         //Intensidad
            gl.uniform3f(shaderProgram.ambientColorUniform, 0.3, 0.3, 0.3);                   //Ambiente
            gl.uniform3f(shaderProgram.diffusePrincipalColorUniform, 1.0, 1.0, 1.0);          //Difusa
            gl.uniform3f(shaderProgram.specularPrincipalColorUniform, 0.4, 0.4, 0.4);         //Especular

            gl.uniform1f(shaderProgramEarth.frameUniform, time/10.0 );
            gl.uniform1f(gl.getUniformLocation(shaderProgramEarth, "scale1"), scale1);
            gl.uniform1f(gl.getUniformLocation(shaderProgramEarth, "low"), low);
            gl.uniform1f(gl.getUniformLocation(shaderProgramEarth, "high"), high);
            gl.uniform3f(shaderProgramEarth.ambientColorUniform, 0.6,0.6,0.6);//0.30, 0.23, 0.19);
            gl.uniform3f(shaderProgramEarth.directionalColorUniform, 1.2, 1.1, 0.7);
            gl.uniform1i(shaderProgramEarth.useLightingUniform,(lighting=="true"));

            gl.uniform3fv(shaderProgramEarth.lightingPrincipalDirectionUniform, sunPosition);
            gl.uniform3fv(shaderProgramEarth.sunPositionUniform, sunPosition);
            gl.uniform1f(shaderProgramEarth.lightPrincipalIntensity, 1.2);                         //Intensidad
            gl.uniform3f(shaderProgramEarth.ambientColorUniform, 0.3, 0.3, 0.3);                   //Ambiente
            gl.uniform3f(shaderProgramEarth.diffusePrincipalColorUniform, 1.0, 1.0, 1.0);          //Difusa
            gl.uniform3f(shaderProgramEarth.specularPrincipalColorUniform, 0.4, 0.4, 0.4);         //Especular

            gl.uniform1f(shaderProgramSky.frameUniform, time/10.0 );
            gl.uniform3f(shaderProgramSky.ambientColorUniform, 0.6, 0.6, 0.6 );
            gl.uniform3f(shaderProgramSky.directionalColorUniform, 1.2, 1.1, 0.7);
            gl.uniform1i(shaderProgramSky.useLightingUniform,(lighting=="true"));

            gl.uniform3fv(shaderProgramSky.lightingPrincipalDirectionUniform, sunPosition);
            gl.uniform3fv(shaderProgramSky.sunPositionUniform, sunPosition);
            gl.uniform1f(shaderProgramSky.lightPrincipalIntensity, 1.2);                         //Intensidad
            gl.uniform3f(shaderProgramSky.ambientColorUniform, 0.3, 0.3, 0.3);                   //Ambiente
            gl.uniform3f(shaderProgramSky.diffusePrincipalColorUniform, 1.0, 1.0, 1.0);          //Difusa
            gl.uniform3f(shaderProgramSky.specularPrincipalColorUniform, 0.4, 0.4, 0.4);         //Especular*/

            gl.uniform1f(shaderProgramWater.frameUniform, time/10.0 );
            gl.uniform3f(shaderProgramWater.ambientColorUniform, 0.6, 0.6, 0.6 );
            gl.uniform3f(shaderProgramWater.directionalColorUniform, 1.2, 1.1, 0.7);
            gl.uniform1i(shaderProgramWater.useLightingUniform,(lighting=="true"));

            gl.uniform3fv(shaderProgramWater.lightingPrincipalDirectionUniform, sunPosition);
            gl.uniform3fv(shaderProgramWater.sunPositionUniform, sunPosition);
            gl.uniform1f(shaderProgramWater.lightPrincipalIntensity, 1.2);                         //Intensidad
            gl.uniform3f(shaderProgramWater.ambientColorUniform, 0.3, 0.3, 0.3);                   //Ambiente
            gl.uniform3f(shaderProgramWater.diffusePrincipalColorUniform, 1.0, 1.0, 1.0);          //Difusa
            gl.uniform3f(shaderProgramWater.specularPrincipalColorUniform, 0.4, 0.4, 0.4);         //Especular*/
            // Definimos la ubicación de la camara

            $("body").keydown(function(e){
	        switch(e.key){
	            case "1":
	                camera=1;
	                break;
	            case "2":
	                camera=2;
	                break;
	            case "3":
	                camera=3;
	                break;                                
	            case "4":
	                camera=4;
	                break;               
	        	}
	   		});


            var pos = contenedorHelicoptero.getPosicion();
            var rot = contenedorHelicoptero.getRotacion();

            mat4.add(matrizVista, matrizVista, pos);
            mat4.lookAt(matrizVista,
                vec3.fromValues(0,alturaCamara,distanciaCamara),
                vec3.fromValues(0,0,0),
                vec3.fromValues(0,1,0)
            );

            var rotY = controlHelicopterio.getYaw();
            var rotacionY = vec3.fromValues(0,1,0)
            var rotacionX = vec3.fromValues(1,0,0)


			switch(camera){
                case 1:
                	vec3.set(eye_point, 0, 0.4 - aumento, 0.4 - aumento);
        			vec3.set(at_point, 0, 0, 0);
        			mat4.lookAt(matrizVista, eye_point, at_point, up_point);
                    mat4.rotateX(matrizVista,matrizVista,(rotarCamaraX%360)*Math.PI/180)                    
                    mat4.rotateY(matrizVista,matrizVista,(rotarCamaraY%360)*Math.PI/180)                     
                    mat4.rotate(matrizVista,matrizVista,Math.PI/2-rotY,rotacionY)
                    var vector = vec3.fromValues(-pos[0],-pos[1],-pos[2])
                    mat4.translate(matrizVista,matrizVista,vector)
                    break;
                case 2:
                    mat4.rotate(matrizVista,matrizVista,Math.PI/2-rot[1],rotacionY)
                    vec3.set(eye_point, -pos[0] - aumento,-pos[1] + aumento/1.5,-pos[2])
                    vec3.set(at_point, 0, 0, 0);
                    mat4.translate(matrizVista,matrizVista,eye_point)
                    break;
                case 3:
                    mat4.rotate(matrizVista,matrizVista,-rot[1],rotacionY)
                    vec3.set(eye_point, -pos[0],-pos[1] + aumento/1.5,-pos[2] + aumento)
                    mat4.translate(matrizVista,matrizVista,eye_point)
                    break;
                case 4:
                    mat4.rotate(matrizVista,matrizVista,Math.PI/4,rotacionX)
                    mat4.rotate(matrizVista,matrizVista,Math.PI/2-rot[1],rotacionY)
                   	vec3.set(eye_point, -pos[0]-aumento/5,-pos[1] + aumento,-pos[2])
                    mat4.translate(matrizVista,matrizVista,eye_point)
                    break;
            }

            gl.useProgram(shaderProgram);
            setMatrixUniforms();
            contenedorHelicoptero.dibujar();
            plataformaHeli.dibujar();

            gl.useProgram(shaderProgramWater);
            setMatrixUniformsWater();
            agua.dibujar(pos[0],pos[2]);

            gl.useProgram(shaderProgramSky);
            setMatrixUniformsSky();
            sky.dibujar();

            gl.useProgram(shaderProgramEarth);
            setMatrixUniformsEarth();
            textureManager.dibujar(pos[0],pos[2]);

            
        }

        function degToRad(a){

        	return Math.sin(a * Math.PI / 180);

        }
        
        function tick() {
            requestAnimFrame(tick);
            time+=1/60;

             // es necesario llamar al metodo update en cada frame
            controlHelicopterio.update();               

            // obtengo la posicion del contenedorHelicoptero
            var p=controlHelicopterio.getPosition();
             
            // obtengo la rotacion respecto del eje Y  
            // obtengo las rotaciones respecto de Z y respecto de X (relativas a contenedorHelicoptero)
            var rz=controlHelicopterio.getPitch();
            var ry=controlHelicopterio.getYaw();
            var rx=controlHelicopterio.getRoll();
            contenedorHelicoptero.actualizar(p.x,p.y,p.z,rx,ry,rz);
                    
            drawScene();

        }
            
        function initMenu(){
            var gui = new dat.GUI();
            gui.add(window, "modo",["wireframe","smooth","edges"]);
            gui.add(window,"scale1",0.1,3).step(0.01);
            gui.add(window,"low",-1,1).step(0.01);
            gui.add(window,"high",-1,1).step(0.01);    
            
        }


        function webGLStart() {
            var canvas = document.getElementById("myCanvas");
            initGL(canvas);
            initShaders();

            plataformaHeli = new PlataformaHeli(shaderProgram);

            controlHelicopterio=new ControlHelicoptero();
            contenedorHelicoptero = new Helicoptero();

            sky = new TexturedSphere(segmentos, segmentos, shaderProgramSky);
            sky.initBuffers();
            sky.initTexture("img/cielo1.jpg");

            agua = new TextureManager(12);
            agua.initParcelas(segmentos, segmentos, shaderProgramWater, 1.0);
            agua.initTexture("img/agua.jpg");
            agua.initReflectionTexture("img/cielo1-refmap.jpg");

            textureManager = new TextureManager(12); //
            textureManager.initParcelas(segmentos, segmentos, shaderProgramEarth,0);
            textureManager.initTexture("img/heightmap.png");
            textureManager.initTexture("img/tierra.jpg");
            textureManager.initTexture("img/roca.jpg");
            textureManager.initTexture("img/pasto.jpg");


            gl.clearColor(66.2, 0.2, 0.2, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.enable(gl.DEPTH_TEST);
    
            $(window).on("resize",onResize);
            initMenu();
            tick();
        }
    
        // cuando el documento HTML esta completo, iniciamos la aplicación
        $(document).ready(function(){
            loadShaders();
        })

    </script>
    
</body>
</html>
